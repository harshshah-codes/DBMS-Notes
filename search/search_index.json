{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":""},{"location":"#important-links-for-the-course","title":"Important Links for the course","text":"<p>Bug</p> <p>If you find a formatting issue in displaying math equations, kindly refresh the page. This is a bug and I am working on it. Hope to remove it soon.</p>"},{"location":"01%20Intro%20to%20DBMS/","title":"Introduction to DBMS","text":""},{"location":"01%20Intro%20to%20DBMS/#levels-of-abstraction","title":"Levels of Abstraction","text":"<ul> <li>Physical Level: Describes how a record is stored on the electronic disk. </li> <li>Logical Level: Describes how data is stored in a database, and relations among the data fields. (<code>For Programmers and Database Engineers</code>)</li> <li>View Level: Application programs hide details of datatype and also some information for security systems.(<code>For end-user</code>)</li> </ul> <p>//TODO: Image Fig(1.1) Page 34</p>"},{"location":"01%20Intro%20to%20DBMS/#schema-and-instance","title":"Schema And Instance","text":"<p>Schema is the way data will be organised and Instance is the actual data. We can consider Schema to be the <code>datatype</code> of variable and Instance to be the <code>value</code> of variable.</p>"},{"location":"01%20Intro%20to%20DBMS/#types-of-schema","title":"Types of schema","text":"<ul> <li>Logical Schema: The overall logical structure of the database.</li> <li>Physical Schema: The overall physical structure of the database.</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#what-is-an-instance","title":"What is an \"Instance\"?","text":"<ul> <li>The actual content of the database at an instant. </li> <li>Similar to the <code>value</code> of the variable.</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#physical-data-independence","title":"Physical Data Independence","text":"<p>The ability to modify the physical schema without changing the logical schema is called Physical Data Independence.</p> <ul> <li>Similar to independence of Interface and Implementation in <code>Object-Oriented Systems</code>.</li> <li>Applications depend on the logical schema.</li> <li>Interfaces should be well defined so that changes in some parts do not seriously affect others.</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#data-models","title":"Data Models","text":"<p>A Data Model is a collection of tools to work and manipulate data, such as, data relationships, data semantics and data constraints.</p> <p>There are various kinds of models:</p> <ul> <li>Relational Models (<code>Main focus for this course</code>)</li> <li>Entity-Relationship Data Models</li> <li>Network Models</li> <li>Object based Data Models</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#relational-model","title":"Relational Model","text":"<ul> <li>All data is stored in table.</li> <li>//TODO: Fig 1.2 p-2 Pg-40</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#data-definition-language-ddl","title":"Data Definition Language (DDL)","text":"<ul> <li>DDL is used for defining the database schema. </li> <li>DDL compiler creates a set a of table templates and stores it under Data Dictionary.</li> <li>Data Dictionary contains metadata, i.e., data about data</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#data-manipulation-language-dml","title":"Data Manipulation Language (DML)","text":"<p>Used for accessing and manipulating data in the database. DML is also known as <code>Query Language</code>.</p> <p>There are two types of DMLs:</p>"},{"location":"01%20Intro%20to%20DBMS/#pure-languages","title":"Pure Languages","text":"<p>This languages are used for proving properties about computational power and for optimisation.</p> <p>There are three sub sections for the pure languages:</p> <ul> <li>Relational Algebra</li> <li>Tuple Relational Calculus </li> <li>Domain related Calculus</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#commercial-languages","title":"Commercial Languages","text":"<p>Mainly used in commercial systems hence named <code>Commercial Languages</code>. </p> <ul> <li><code>SQL</code> is an example of widely used commercial language. </li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#sql","title":"SQL","text":"<p>The most widely used commercial DML.</p> <ul> <li>SQL is embedded to be used with another high-level language to solve complex problems</li> </ul> <p>Applications created generally access database through some language extensions or some APIs.</p>"},{"location":"01%20Intro%20to%20DBMS/#database-design","title":"Database Design","text":"<p>There are two major types of design:</p>"},{"location":"01%20Intro%20to%20DBMS/#logical-design","title":"Logical Design","text":"<p>Talks about the logical layout of the database.</p> <p>Depends on:</p> <ul> <li>Business decision: What attributes need to be recorded in the database.</li> <li>Computer Science decision: What relation schemas are required within the database.</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#physical-design","title":"Physical Design","text":"<p>Talks about the physical layout of the database.</p>"},{"location":"01%20Intro%20to%20DBMS/#design-approaches","title":"Design Approaches","text":"<p>The methodology used to ensure that each relationship in database is good.</p> <p>This is achieved by two methods:</p> <ul> <li>Entity-Relationship Model</li> <li>Normalization Theory</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#relational-model_1","title":"Relational Model","text":"<p>It only contains flat, atomic values, i.e., it cannot contain values as any composite data.</p>"},{"location":"01%20Intro%20to%20DBMS/#object-relational-data-model","title":"Object-Relational Data Model","text":"<ul> <li>It extends the Relational Model using object oriented paradigm with added datatypes</li> <li>Attributes can have composite data types</li> <li>Provide upward compatibility with existing relational languages</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#extensible-markup-language-xml","title":"Extensible Markup Language (XML)","text":"<ul> <li>Originally a markup language developed by WWW Consortium</li> <li>It had the ability to specify new tags, and created nested TAG structure. </li> <li>These features made it the basis for all new generation data interchange format</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#database-engine","title":"Database Engine","text":"<p>It is basically composed of three main components:</p> <ul> <li>Storage Manager</li> <li>Query Processing</li> <li>Transaction Manager</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#storage-manager","title":"Storage Manager","text":"<p>It is a program module that provides the interface between the low level data stored in the database and the application programs and queries submitted to the system. </p> <p>The main functions of the Storage Manager are the:</p> <ul> <li>It interacts with the OS file manager.</li> <li>It efficiently stores, retrieves and updates data.</li> </ul>"},{"location":"01%20Intro%20to%20DBMS/#query-processing","title":"Query Processing","text":"<pre><code>\nflowchart TB\nA[Query] --&gt; B{Parser and \\n translator}\nB --&gt; C(Relational-Algebra Expression)\nC --&gt; D{Optimiser}\nD --&gt; E(Execution Plan)\nE --&gt; F{Evaluation Engine}\nF --&gt;|Data| G(Query Output)\nH((Statistics About \\nData)) --&gt; D\n</code></pre>"},{"location":"01%20Intro%20to%20DBMS/#transaction-manager","title":"Transaction Manager","text":""},{"location":"02%20Intro%20to%20Relational%20Model/","title":"Introduction to Relational Model","text":""},{"location":"02%20Intro%20to%20Relational%20Model/#attributes","title":"Attributes","text":"<ul> <li>The parameters in the database schema is known as attributes.</li> <li>The set of allowed values for the attribute is known as the domain of attribute. </li> <li>Attribute values are conventionally preferred to be atomic</li> <li><code>null</code> is a special value and is available in the domain of each attribute. It indicates that the value is unknown.</li> <li>The <code>null</code> value needs to be checked thoroughly since it may cause complications.</li> </ul>"},{"location":"02%20Intro%20to%20Relational%20Model/#schema-and-instance","title":"Schema and Instance","text":"<ul> <li>Schema: A basic template of the database.</li> <li>Instance: Actual data in the database.</li> </ul>"},{"location":"02%20Intro%20to%20Relational%20Model/#schema","title":"Schema","text":"<p>A schema is mathematically as a relation. </p> <p>If there are \\(n\\) attributes say, \\(A_1, A_2, A_3, ..., A_n\\). Then \\(R=(A_1, A_2, A_3, ...,A_n)\\) is the relational schema.</p> \\[ \\text{Let } D_1 \\text{ be domain of }A_1, D_2 \\text{ be domain of } A_2, \\text{ and so on}, \\\\ \\ \\\\ \\text{ Then each row of the relational database } R \\subset D_1 \\text{x }D_2 \\text{x } D_3 ... \\text{x }D_n \\] <p>Thus each row is an \\(n\\)-tuple value \\(r \\subset R\\).</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#instance","title":"Instance","text":"<p>A set of tuples formed using the schema is known as the instance.</p> <p>Some properties of instance:</p> <ul> <li>It can be unordered.</li> <li>There can't be identical rows.</li> </ul>"},{"location":"02%20Intro%20to%20Relational%20Model/#keys","title":"Keys","text":"<p>Since we know that each row in the database is unique, we consider a set \\(K\\) such that \\(K \\subset R\\).</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#superkey","title":"Superkey","text":"<p>Now \\(K\\) is a superkey of \\(R\\) is \\(K\\) is sufficient enough to identify unique rows in the database for each possible relation \\(R\\).</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#candidate-key","title":"Candidate key","text":"<p>Now if the superkey \\(K\\) is minimal, i.e., no subset of \\(K\\) is a key then \\(K\\) becomes a candidate key.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#primary-key","title":"Primary key","text":"<p>One of the candidate key is selected to be the primary key</p> <p>Choosing a primary key</p> <p>While choosing a candidate key to be a primary key make sure that the primary key gives you some additional information.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#surrogate-key","title":"Surrogate key","text":"<p>A surrogate key is a synthetic key created when the data is not unique, hence it is not derived from the data itself.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#foreign-key","title":"Foreign key","text":"<p>When referencing to another table the original table must contain a key known as foreign key that can be used as identifier for the referenced table.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#compound-key","title":"Compound key","text":"<p>When more than one attributes are combined to be used as key, then it is called a compound or composite key.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#relational-operators","title":"Relational operators","text":""},{"location":"02%20Intro%20to%20Relational%20Model/#select-operator","title":"<code>SELECT</code> Operator","text":"<p>The <code>SELECT</code> operator selects some specific rows based on the condition given.</p> <p>Let there be a relation \\(r\\) already defined. Then the <code>SELECT</code> operator denoted using \\(\\sigma_{\\text{conditions}}(r)\\) filters out the required rows based on the conditions given and gives them as output.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#project-operator","title":"<code>PROJECT</code> Operator","text":"<p>The <code>PROJECT</code> operator selects some specific columns based on the columns asked for.</p> <p>Let there be a relation \\(r\\) already defined. Then the <code>PROJECT</code> operator denoted using \\(\\pi_{\\text{columnnames}}(r)\\) filters out the required columns based on the column_names given and removes the duplicate columns if left after the projection and gives them as output.</p> <p>Tip</p> <p>It is sometimes used to retrieve the original relations from the cartesian product using the following formula: \\(r=\\pi_r(r\\text{ x }s)\\)</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#union-operator","title":"<code>UNION</code> Operator","text":"<p>Gives you a <code>UNION</code> of two relations and returns only the unique rows after the operation. Denoted by $ \\cup $</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#difference-operator","title":"<code>DIFFERENCE</code> Operator","text":"<p>Let us say that \\(X\\) and \\(Y\\) are two relation defined beforehand. Then the <code>DIFFERENCE</code> of \\(X\\) and \\(Y\\), i.e., \\(X-Y\\) returns the rows that are present in \\(X\\) and not in \\(Y\\).</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#intersection-operator","title":"<code>INTERSECTION</code> Operator","text":"<p>Let us say that \\(X\\) and \\(Y\\) are two relation defined beforehand. Then the <code>INTERSECTION</code> operator returns the rows that are common to both \\(X\\) as well as \\(Y\\). It is denoted using \\(\\cap\\).</p> <p>Note</p> <p>\\(r\\cap s = r - (r - s)\\)</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#rename-operator","title":"<code>RENAME</code> Operator","text":"<p><code>RENAME</code> allows us to call a relation, by other name. It is denoted by \\(\\rho_{\\text{new name}}(\\text{old name})\\)</p> <p>Abstract</p> <p>You can compose several relational operators.</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#natural-join-operator","title":"<code>NATURAL JOIN</code> Operator","text":"<p>If two relations have some identical attributes, then <code>NATURAL JOIN</code> returns only the union of those rows where the identical attributes have the same values in all the relations. It is denoted using \\(\\bowtie\\).</p> <p>Example: \\(r\\bowtie s\\)</p>"},{"location":"02%20Intro%20to%20Relational%20Model/#points-to-note","title":"Points to Note","text":"<ul> <li>Each query input and output is a table.</li> <li>Data in the output table appears in atleast one of the input table.</li> <li>Relational algebra may not work for some complex calculations.</li> </ul>"},{"location":"03%20Intro%20To%20SQL/","title":"Introduction to SQL","text":""},{"location":"03%20Intro%20To%20SQL/#datatypes-in-sql","title":"Datatypes in SQL","text":"DataType Description <code>char(n)</code> A string with fixed length <code>n</code> <code>varchar(n)</code> A string with maximum length <code>n</code> <code>int</code> Integer <code>numeric(p, d)</code> A number with maximum <code>p</code> digits with a maximum of <code>d</code> digits after the decimal point <code>float(n)</code> Floating point number with a precision of <code>n</code> digits <p>Tip</p> <p>Refer to CheatSheet for quick access to most useful SQL commands.</p>"},{"location":"03%20Intro%20To%20SQL/#additional-basic-operationscommands","title":"Additional Basic Operations/Commands","text":""},{"location":"03%20Intro%20To%20SQL/#cartesian-product","title":"Cartesian Product","text":"<p>Let us say you want cartesian product of two tables <code>A</code> and <code>B</code>. You can do it using the following SQL command:</p> <pre><code>SELECT * FROM A, B;\n</code></pre> <p>Failure</p> <p>This will give all combinations between <code>A</code> and <code>B</code> ad some may not be meaningful.</p> <p>Example, if there is a table <code>A</code> with teacher names and table <code>B</code> with their departments. Then cartesian product will give all combinations of teacher names and departments and not the department of each teacher. You need to use <code>JOIN</code> or some where-clause for that purpose.</p> <p>Warning</p> <p>For same attributes in both tables, the SQL will present them as <code>A.attribute</code> and <code>B.attribute</code>.</p>"},{"location":"03%20Intro%20To%20SQL/#rename-as-operation","title":"<code>RENAME AS</code> Operation","text":"<p>In SQL you can assign an alias to a table as well as an attribute. The command to do this is</p> <pre><code>-- For attributes\nSELECT A.attribute AS alias_name FROM A;\n\n-- For table name\nSELECT * FROM A AS alias_name;\n\n-- You can also give multiple names to the same table\nSELECT * FROM A AS alias_name1, A AS alias_name2;\n</code></pre> <p>You can now use the alias in the whole query.</p> <p>Tip</p> <p>Keyword <code>AS</code> is optional in SQL. You can omit that and remodify the query to <pre><code>SELECT A.attribute alias_name FROM A;\n</code></pre></p>"},{"location":"03%20Intro%20To%20SQL/#string-operations","title":"String Operations","text":"<p>To compare strings in SQL, you can use the like operator. The like operator uses patterns described by two special characters:</p> <ul> <li><code>%</code> - The <code>%</code> operator is equivalent to any substring in the string.</li> <li><code>_</code> - The <code>_</code> operator is equivalent to any single character in the string.</li> </ul>"},{"location":"03%20Intro%20To%20SQL/#operator","title":"<code>%</code> operator","text":"<p>Let us define a dummy query that checks for name of teachers that contain the substring <code>ma</code> in their name.</p> <pre><code>SELECT *\nFROM teachers\nWHERE name LIKE '%ma%';\n</code></pre> <p>Note</p> <p>Here the first % operator says that any string can come before ma and the second % operator says that any string can come after ma.</p> <p>If I modify the same query to</p> <pre><code>SELECT *\nFROM teachers\nWHERE name LIKE '%ma';\n</code></pre> <p>Now this will give the names of the teachers that contain the substring <code>ma</code> at the end of their name.</p>"},{"location":"03%20Intro%20To%20SQL/#_-operator","title":"<code>_</code> operator","text":"<p>Let us say that I want to find the names of teachers that have exactly 6 characters in their last name and ends in <code>\"ma\"</code>. I can do this using the <code>_</code> operator.</p> <pre><code>SELECT name\nFROM teachers\nWHERE name LIKE '____ma';\n</code></pre>"},{"location":"03%20Intro%20To%20SQL/#points-to-note-for-string-operations","title":"Points to note for <code>string operations</code>","text":"<ul> <li>Patterns are case sensitive.</li> <li>SQL also supports string concatenation using <code>||</code> operator.</li> <li>SQL also supports <code>convert to uppercase</code> and <code>convert to lowercase</code> operations.</li> </ul>"},{"location":"03%20Intro%20To%20SQL/#order-by-operation","title":"<code>ORDER BY</code> Operation","text":"<p>You can order the results by a particular attribute using the <code>ORDER BY</code> operation. The syntax is</p> <pre><code>SELECT attribute_name\nFROM table_name\nWHERE ....\nORDER BY attribute_name;\n</code></pre> <p>Warning</p> <p>The attribute you use in <code>ORDER BY</code> operation should be displayed in the query. You cannot use an attribute that is not displayed in the query, i.e., the column that is used in <code>ORDER BY</code> operation should be present in the <code>SELECT</code> clause.</p>"},{"location":"03%20Intro%20To%20SQL/#in-operator","title":"<code>IN</code> Operator","text":"<p>You can check whether an attribute value is in a set of values using the <code>IN</code> operator. The syntax is</p> <p>Let us filter out all instructor from department 'Comp. Sci.' and 'Physics'.</p> <pre><code>SELECT *\nFROM instructors\nWHERE dept_name IN ('Comp. Sci.', 'Physics');\n</code></pre>"},{"location":"03%20Intro%20To%20SQL/#group-by-operator","title":"<code>GROUP BY</code> Operator","text":"<p>You can group attributes based on a particular attribute using the <code>GROUP BY</code> operation. The syntax is</p> <pre><code>SELECT attribute_name\nFROM table\nWHERE ....\nORDER BY ...\nGROUP BY attribute_name;\n</code></pre> <p>Failure</p> <p>The attribute you use in <code>GROUP BY</code> operation should be displayed in the query. You cannot use an attribute that is not displayed in the query, i.e., the column that is used in <code>GROUP BY</code> operation should be present in the <code>SELECT</code> clause except the use of aggregate function.</p>"},{"location":"03%20Intro%20To%20SQL/#set-operations","title":"Set Operations","text":""},{"location":"03%20Intro%20To%20SQL/#union","title":"UNION","text":"<p>Let us filter out all instructor from department 'Comp. Sci.' and 'Physics'.</p> <pre><code>SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'\nUNION\nSELECT name FROM instructor WHERE dept_name = 'Physics';\n</code></pre>"},{"location":"03%20Intro%20To%20SQL/#intersect","title":"INTERSECT","text":"<p>Let us filter out all instructor from department 'Comp. Sci.' after 2000.</p> <pre><code>SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.'\nINTERSECT\nSELECT name FROM instructor WHERE join_date &gt; '2000'\n</code></pre>"},{"location":"03%20Intro%20To%20SQL/#except","title":"EXCEPT","text":"<p>Let us filter out all instructor from department 'Physics' after 2000.</p> <pre><code>SELECT name FROM instructor WHERE dept_name = 'Physics'\nEXCEPT\nSELECT name FROM instructor WHERE join_date &lt; '2000'\n</code></pre>"},{"location":"03%20Intro%20To%20SQL/#null-values","title":"NULL Values.","text":"<p><code>NULL</code> values in SQL basically means that the values for the attribute has not been defined yet or the value does not exist yet. However, you can also assign null to attributes in SQL.</p>"},{"location":"03%20Intro%20To%20SQL/#arithmetic-operations-involving-null","title":"Arithmetic Operations Involving <code>NULL</code>","text":"<p>You can peform arithmetic operations involving <code>NULL</code> values in SQL. The result of any arithmetic operation involving <code>NULL</code> is <code>NULL</code>.</p>"},{"location":"03%20Intro%20To%20SQL/#comparing-null-values","title":"Comparing <code>NULL</code> values","text":"<p>You can compare <code>NULL</code> values in SQL. The result of any comparison involving <code>NULL</code> is <code>UNKNOWN</code>.</p> <p>You can only use <code>IS NULL</code> and <code>IS NOT NULL</code> to check for <code>NULL</code> values.</p>"},{"location":"03%20Intro%20To%20SQL/#null-and-boolean-algebra","title":"<code>NULL</code> and Boolean Algebra","text":""},{"location":"03%20Intro%20To%20SQL/#or-operator","title":"<code>OR</code> Operator","text":"<ul> <li><code>NULL or true</code> returns <code>true</code></li> <li><code>NULL or false</code> returns <code>false</code></li> <li><code>NULL or NULL</code> returns <code>unknown</code></li> </ul>"},{"location":"03%20Intro%20To%20SQL/#and-operator","title":"<code>AND</code> operator","text":"<ul> <li><code>NULL and true</code> returns <code>unknown</code></li> <li><code>NULL and false</code> returns <code>false</code></li> <li><code>NULL and NULL</code> returns <code>unknown</code></li> </ul>"},{"location":"03%20Intro%20To%20SQL/#not-operator","title":"<code>NOT</code> operator","text":"<ul> <li><code>not NULL</code> returns <code>unknown</code></li> </ul> <p>Tip</p> <p>In SQL, <code>unknown</code> is treated as <code>false</code>.</p>"},{"location":"DBMS-Query-Cheatsheet/","title":"Cheatsheet","text":""},{"location":"DBMS-Query-Cheatsheet/#to-create-a-table","title":"To create a table","text":"<pre><code>CREATE table table_name(column_name_1 data_type constraint, column_name_2 data_type constraint)\n</code></pre> <p>Warning</p> <p>Add <code>primary</code> key after the <code>colum_name</code> if that column is primary.</p>"},{"location":"DBMS-Query-Cheatsheet/#to-select-from-a-table","title":"To select from a table","text":""},{"location":"DBMS-Query-Cheatsheet/#all-columns","title":"All columns","text":"<pre><code>select * from table_name\n</code></pre>"},{"location":"DBMS-Query-Cheatsheet/#specific-column","title":"Specific column","text":"<pre><code>select column_name(s) from table_name\n</code></pre>"},{"location":"DBMS-Query-Cheatsheet/#to-insert-into-table","title":"To insert into table","text":"<pre><code>insert into table_name values(all_values_seprated_by_comma)\n</code></pre> <p>Warning</p> <p>Note: <code>char</code> and <code>varchar</code> must be enclosed with single quotes(<code>'</code>)</p>"},{"location":"DBMS-Query-Cheatsheet/#creating-keys","title":"Creating keys","text":""},{"location":"DBMS-Query-Cheatsheet/#primary-key","title":"Primary key","text":"<p>Add the <code>primary key</code> keyword after the column_name.</p> <p>Tip</p> <p><code>primary key</code> declaration on an attribute ensures that the attribute is <code>not null</code></p>"},{"location":"DBMS-Query-Cheatsheet/#composite-primary-key","title":"Composite primary key","text":"<p>Add the <code>primary key (column_name_1, column_name_2, ....)</code> at the end before the closing parentheses <code>)</code> while creating the table.</p>"},{"location":"DBMS-Query-Cheatsheet/#foreign-key","title":"Foreign key","text":"<p>Add the <code>foreign key (column_name) references parent_table(parent_column)</code>at the end before the closing parentheses <code>)</code> while creating the table.</p>"},{"location":"DBMS-Query-Cheatsheet/#deleting-rows","title":"Deleting rows","text":"<pre><code>delete from table_name where delete_condition(s)\n</code></pre>"},{"location":"DBMS-Query-Cheatsheet/#alter","title":"Alter","text":""},{"location":"DBMS-Query-Cheatsheet/#adding-an-attribute","title":"Adding an attribute","text":"<pre><code>alter table table_name add attribute_name data_type\n</code></pre>"},{"location":"DBMS-Query-Cheatsheet/#deleting-an-attribute","title":"Deleting an attribute","text":"<pre><code>alter table table_name drop attribute_name\n</code></pre>"},{"location":"DBMS-Query-Cheatsheet/#important-points-to-note","title":"Important Points to Note","text":"<ul> <li><code>delete</code>: Delete row(s) from the table. But schema is not lost</li> <li><code>drop</code>: Entire table is deleted along with schema.</li> <li><code>truncate</code>: Deletes the table along with schema, but the schema is regenerated.</li> </ul>"}]}